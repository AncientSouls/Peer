{"version":3,"sources":["../src/lib/index.js"],"names":["Peer","apiManager","cursorsManager","bundleQueuesManager","clientsManager","adapterSend","clientId","bundles","_sendBundles","adapterDisconnected","_clientDisconnected","receivedData","data","_receivedData","apiQuery","query","callback","options","cursor","_options","defaults","needCursor","_query","new","cursorId","id","on","old","current","stop","changes","isClone","sendData","encode","queries","bundle","executeBundle","clientDisconnected","_data","decode","_executeBundle","receiveQuery"],"mappings":"wgBAAA;;GAIA,0B,yCACA,6CAKA,8B,+QAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;MAIMA,K,YAEJ;;;;;;KAOA,cAAYC,UAAZ,CAAwBC,cAAxB,CAAwCC,mBAAxC,CAA6DC,cAA7D,CAA6E,2CAC3E,KAAKH,UAAL,CAAkBA,UAAlB,CACA,KAAKC,cAAL,CAAsBA,cAAtB,CACA,KAAKC,mBAAL,CAA2BA,mBAA3B,CACA,KAAKC,cAAL,CAAsBA,cAAtB,CAEAH,WAAWI,WAAX,CAAyB,SAACC,QAAD,CAAWC,OAAX,QAAuB,OAAKC,YAAL,CAAkBF,QAAlB,CAA4BC,OAA5B,CAAvB,CAAzB,CAEAH,eAAeK,mBAAf,CAAqC,SAACH,QAAD,QAAc,OAAKI,mBAAL,CAAyBJ,QAAzB,CAAd,CAArC,CACAF,eAAeO,YAAf,CAA8B,SAACL,QAAD,CAAWM,IAAX,QAAoB,OAAKC,aAAL,CAAmBP,QAAnB,CAA6BM,IAA7B,CAApB,CAC/B,CAED;;;;;;;;;sDAUIN,Q,CAAUQ,Q,CAAUC,K,CAAOC,Q,CAAUC,O,CAAS,CAChD,GAAIC,OAAJ,CACA,GAAIC,UAAW,iBAAOC,QAAP,CAAgBH,OAAhB,CAAyB,CACtCI,WAAY,IAD0B,CAAzB,CAAf,CAGA,GAAIC,QAAS,CAAEhB,iBAAF,CAAYQ,iBAAZ,CAAsBC,WAAtB,CAAb,CACA,GAAII,SAASE,UAAb,CAAyB,CACvBH,OAAS,KAAKhB,cAAL,CAAoBqB,GAApB,CAAwB,CAAEjB,iBAAF,CAAYQ,iBAAZ,CAAsBC,WAAtB,CAAxB,CAAT,CACAO,OAAOE,QAAP,CAAkBN,OAAOO,EAC1B,CACD,GAAI,MAAOT,SAAP,EAAoB,UAApB,EAAkCE,MAAtC,CAA8C,CAC5CA,OAAOQ,EAAP,CAAU,IAAV,CAAgB,SAACC,GAAD,CAAMC,OAAN,CAAeC,IAAf,CAAqBC,OAArB,CAA8BC,OAA9B,CAA0C,CACxDF,OACAb,SAASE,MAAT,CACD,CAHD,CAID,CACD,KAAKd,cAAL,CAAoB4B,QAApB,CAA6B1B,QAA7B,CAAuC,eAAK2B,MAAL,CAAY,CAACC,QAAQ,CAACZ,MAAD,CAAT,CAAZ,CAAvC,EACA,MAAOJ,OACR,CAED;;;;;;;;uCASKJ,Q,CAAUC,K,CAAOC,Q,CAAUC,O,CAAS,CAIxC,CAHC;;OAKF;;;;;;2DAOekB,M,CAAQ,CACrB,KAAKhC,mBAAL,CAAyBiC,aAAzB,CAAuCD,MAAvC,CACD,CAED;;;;uDAKa7B,Q,CAAUC,O,CAAS,CAC9B,KAAKH,cAAL,CAAoB4B,QAApB,CAA6B1B,QAA7B,CAAuC,eAAK2B,MAAL,CAAY,CAAC1B,eAAD,CAAZ,CAAvC,CACD,CAED;;;qEAIoBD,Q,CAAU,CAC5BL,WAAWoC,kBAAX,CAA8B/B,QAA9B,CACD,CAED;;;;yDAKcA,Q,CAAUgC,K,CAAO,CAC7B,GAAI1B,MAAO,eAAK2B,MAAL,CAAY3B,IAAZ,CAAX,CACA;AACA,GAAIA,KAAKL,OAAT,CAAkB,iGAChB,kBAAmBK,KAAKL,OAAxB,oHAAiC,IAAxB4B,OAAwB,aAC/B,KAAKK,cAAL,CAAoBL,MAApB,CACD,CAHe,4LAIjB,CACD;AACA,GAAIvB,KAAKsB,OAAT,CAAkB,oGAChB,mBAAkBtB,KAAKsB,OAAvB,yHAAgC,IAAvBnB,MAAuB,cAC9B,KAAKd,UAAL,CAAgBwC,YAAhB,CAA6BnC,QAA7B,CAAuCS,MAAMD,QAA7C,CAAuDC,MAAMA,KAA7D,CAAoEA,MAAMS,QAA1E,CACD,CAHe,mMAIjB,CACF,C,mBAGH","file":"index.js","sourcesContent":["/**\n * @module ancient-peer\n */\n\nimport PSON from 'pson';\nimport {\n  Cursor,\n  BundleQueuesManager,\n  CursorsManager,\n} from 'ancient-cursor';\nimport lodash from 'lodash';\n\n// apiManager.adapterSend\n// peer.sendBundles\n// clientsManager.sendData\n\n// clientsManager.receivedData\n// peer.executeBundle\n// bundleQueuesManager.executeBundle\n// cursor.set|cursor.splice\n\n// clientsManager.adapterDisconnected\n// peer.clientDicsconnected\n// apiManager.clientDicsonnected\n// ...apiManager.cursorDestroyed\n\n/**\n * @class\n * @memberof module:ancient-peer\n */\nclass Peer {\n  \n  /**\n   * @constructs Peer\n   * @param {ApiManager} apiManager\n   * @param {cursorsManager} cursorsManager\n   * @param {BundleQueuesManager} bundleQueuesManager\n   * @param {clientsManager} clientsManager\n   */\n  constructor(apiManager, cursorsManager, bundleQueuesManager, clientsManager) {\n    this.apiManager = apiManager;\n    this.cursorsManager = cursorsManager;\n    this.bundleQueuesManager = bundleQueuesManager;\n    this.clientsManager = clientsManager;\n    \n    apiManager.adapterSend = (clientId, bundles) => this._sendBundles(clientId, bundles);\n\n    clientsManager.adapterDisconnected = (clientId) => this._clientDisconnected(clientId);\n    clientsManager.receivedData = (clientId, data) => this._receivedData(clientId, data);\n  }\n  \n  /**\n   * Send `query` to api by `apiQuery` on client by `clientId`. Wait first results and call callback with `cursor` as argument. If cursor not needed, you can send `options` with `{ needCursor: false }`. Returns cursor without data, waiting bundles from remote client.\n   * @param clientId\n   * @param apiQuery\n   * @param query\n   * @param {Peer~firstDataCallback} [callback]\n   * @param {Object} [options]\n   * @param {Boolean} [options.needCursor=true]\n   * @returns {Cursor}\n   */\n  ask(clientId, apiQuery, query, callback, options) {\n    var cursor;\n    var _options = lodash.defaults(options, {\n      needCursor: true,\n    });\n    var _query = { clientId, apiQuery, query };\n    if (_options.needCursor) {\n      cursor = this.cursorsManager.new({ clientId, apiQuery, query });\n      _query.cursorId = cursor.id;\n    }\n    if (typeof(callback) == 'function' && cursor) {\n      cursor.on(null, (old, current, stop, changes, isClone) => {\n        stop();\n        callback(cursor);\n      });\n    }\n    this.clientsManager.sendData(clientId, PSON.encode({queries:[_query]}));\n    return cursor;\n  }\n  \n  /**\n   * Send `query` to api by `apiQuery` on client by `clientId`. Wait first results and call callback with `cursor` as argument. If cursor not needed, you can send `options` with `{ needCursor: false }`. Returns cursor without data, waiting bundles from remote client.\n   * @param apiQuery\n   * @param query\n   * @param {Peer~firstDataCallback} [callback]\n   * @param {Object} [options]\n   * @param {Boolean} [options.needCursor=true]\n   * @returns {Cursor}\n   */\n  exec(apiQuery, query, callback, options) {\n    /**\n     * @todo How to send query from local app clientId, without manually created pseudo-transport?\n     */\n  }\n\n  /**\n   * Not for manual usage. You can override it for extend with custom logic. Used in receivedData, for send bundles to cursors.\n   * @param {ApiManager} apiManager\n   * @param {cursorsManager} cursorsManager\n   * @param {BundleQueuesManager} bundleQueuesManager\n   * @param {clientsManager} clientsManager\n   */\n  _executeBundle(bundle) {\n    this.bundleQueuesManager.executeBundle(bundle);\n  }\n  \n  /**\n   * Not for manual usage. You can override it for extend with custom logic. Used in adapter `apiManager.adapterSend`, for provide and encode bundles from api to client.\n   * @param clientId\n   * @param {Bundle[]} bundles\n   */\n  _sendBundles(clientId, bundles) {\n    this.clientsManager.sendData(clientId, PSON.encode({bundles}));\n  }\n  \n  /**\n   * Not for manual usage. You can override it for extend with custom logic. Used in adapter `clientsManager.adapterDisconnected`, for inform each api about client disconnected and it cursors destroyed.\n   * @param clientId\n   */\n  _clientDisconnected(clientId) {\n    apiManager.clientDisconnected(clientId);\n  }\n\n  /**\n   * Not for manual usage. You can override it for extend with custom logic. Used in adapter `clientsManager.receivedData`, and provide encripted object data structure with `data.queries` and `data.bundles`, from other peer on remote client to `this.apiManager` and `this.cursorsManager` in this peer.\n   * @param clientId\n   * @param \n   */\n  _receivedData(clientId, _data) {\n    var data = PSON.decode(data);\n    // Apply data.bundles.\n    if (data.bundles) {\n      for (var bundle of data.bundles) {\n        this._executeBundle(bundle);\n      }\n    }\n    // Provide queries to apis.\n    if (data.queries) {\n      for (var query of data.queries) {\n        this.apiManager.receiveQuery(clientId, query.apiQuery, query.query, query.cursorId);\n      }\n    }\n  }\n}\n\n/**\n * Called after cursor gets first bundle.\n * @callback Peer~firstDataCallbackCallback\n * @memberof module:ancient-peer\n * @param {Cursor} cursor\n */"]}